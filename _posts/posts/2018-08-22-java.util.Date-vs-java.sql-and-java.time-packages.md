---
layout: post
category: post
title: java.util.Date vs classes in java.sql and java.time packages
date: 2018-08-22
excerpt: "Forget java.util.Date! Beware of java.sql.Date, Time and Timestamp! Use java.time.LocalDate, LocalTime, LocalDateTime or ZonedDateTime!"
tags: [java cheatsheet, Date, Time, Timestamp, LocalDate, LocalTime, LocalDateTime, ZonedDateTime]
comments: true
---
tl;dr  
Differences from java.util.Date:
- java.sql's Date, Time and Timestamp are special representations of java.util.Date:
  - sql.Date -> util.Date: yyyy-MM-dd 00:00:00.000
  - sql.Time -> util.Date: 1970-01-01 HH:mm:ss.SSS
  - sql.Timestamp -> util.Date: yyyy-MM-dd HH:mm:ss.SSS
- JAVA 8 date/tim api (java.time package) are immutable and thread safe
- java.time.LocalDate, LocalTime and LocalDateTime are
  - special representations for Date, Time and - both - Date and Time
  - without time zone, for this there is ZonedDateTime [JDOC](https://docs.oracle.com/javase/10/docs/api/java/time/ZonedDateTime.html)
- never use/avoid direct usage of java.sql.Date, Time and especially Timestamp (as stated in [JDOC](https://docs.oracle.com/javase/10/docs/api/java/sql/Timestamp.html)).
- but use java.sql classes for converting e.g. LocalDate into util.Date: `java.util.Date date = java.sql.Date.valueOf(localDate)`
- best practice for DB design: use long instead of SQL types Date, Time or Timestamp

# Example
  {%highlight java%}
  SimpleDateFormat formatter = new SimpleDateFormat(("yyyy-MM-dd HH:mm:ss.SSS"));
  
  System.out.println(
    formatter.format(
      java.sql.Date.valueOf(LocalDate.now())
    )
  );
  // 2018-08-22 00:00:00.000
  
  System.out.println(
    formatter.format(
      java.sql.Time.valueOf(LocalTime.now())
    )
  );
  // 1970-01-01 19:52:20.000
  
  System.out.println(
    formatter.format(
      java.sql.Timestamp.valueOf(LocalDateTime.now())
    )
  );
  // 2018-08-22 19:52:20.122
  {%endhighlight%}

# java.sql: Date, Time, Timestamp

- java.sql.Date/Time/Time extends java.util.Date

- [sql.Date, JDoc](https://docs.oracle.com/javase/10/docs/api/java/sql/Date.html):
> A thin wrapper around a millisecond value that allows JDBC to identify this as an SQL DATE value. A milliseconds value represents the number of milliseconds that have passed since January 1, 1970 00:00:00.000 GMT.  
> To conform with the definition of SQL DATE, the millisecond values wrapped by a java.sql.Date instance must be 'normalized' by setting the hours, minutes, seconds, and milliseconds to zero in the particular time zone with which the instance is associated.

- [sql.Time, JDoc](https://docs.oracle.com/javase/10/docs/api/java/sql/Time.html):
> A thin wrapper around the java.util.Date class that allows the JDBC API to identify this as an SQL TIME value. The Time class adds formatting and parsing operations to support the JDBC escape syntax for time values.  
> The date components should be set to the "zero epoch" value of January 1, 1970 and should not be accessed.

- [sql.Timestamp, JDoc](https://docs.oracle.com/javase/10/docs/api/java/sql/Timestamp.html):
> A thin wrapper around java.util.Date that allows the JDBC API to identify this as an SQL TIMESTAMP value. It adds the ability to hold the SQL TIMESTAMP fractional seconds value, by allowing the specification of fractional seconds to a precision of nanoseconds. A Timestamp also provides formatting and parsing operations to support the JDBC escape syntax for timestamp values.  
> The precision of a Timestamp object is calculated to be either:  
> - 19 , which is the number of characters in yyyy-mm-dd hh:mm:ss  
> - 20 + s , which is the number of characters in the yyyy-mm-dd hh:mm:ss.[fff...] and s represents the scale of the given Timestamp, its fractional seconds precision. 
> ...  
> Due to the differences between the Timestamp class and the java.util.Date class mentioned above, **it is recommended that code not view Timestamp values generically as an instance of java.util.Date**. The inheritance relationship between Timestamp and java.util.Date really denotes implementation inheritance, and not type inheritance.  
> To conform with the definition of SQL DATE, the millisecond values wrapped by a java.sql.Date instance must be 'normalized' by setting the hours, minutes, seconds, and milliseconds to zero in the particular time zone with which the instance is associated.

- [Stackoverflow, "java.util.Date vs java.sql.Date"](https://stackoverflow.com/questions/2305973/java-util-date-vs-java-sql-date):
>Basically databases usually support at least three forms of datetime fields which are date, time and timestamp. Each of these have a corresponding class in JDBC and each of them extend java.util.Date. Quick semantics of each of these three are the following:  
>- **java.sql.Date corresponds to SQL DATE** which means it stores years, months and days while hour, minute, second and millisecond are ignored. Additionally sql.Date isn't tied to timezones.  
>- **java.sql.Time corresponds to SQL TIME** and as should be obvious, only contains information about hour, minutes, seconds and milliseconds.  
>- **java.sql.Timestamp corresponds to SQL TIMESTAMP** which is exact date to the nanosecond (note that util.Date only supports milliseconds!) with customizable precision.  

  Also interesting the advise on Stack Overflow:
><h2>I'm really saying that none of the Dates should be used at all.</h2>  
>What I am saying that **save the milliseconds/nanoseconds as plain longs and convert them to whatever objects you are using** (obligatory joda-time plug). One hacky way which can be done is to store the date component as one long and time component as another, for example right now would be 20100221 and 154536123. These magic numbers can be used in SQL queries and will be portable from database to another and will let you avoid this part of JDBC/Java Date API:s entirely.

# LocalDate, LocalTime, LocalDateTime
[LocalDate, JDOC](https://docs.oracle.com/javase/10/docs/api/java/time/LocalDate.html):
> **A date without a time-zone in the ISO-8601 calendar system, such as 2007-12-03**.  
> LocalDate is an immutable date-time object that represents a date, **often viewed as year-month-day**. Other date fields, such as day-of-year, day-of-week and week-of-year, can also be accessed. For example, the value **"2nd October 2007"** can be stored in a LocalDate. ...

Both, LocalTime and LocalDateTime are represented - unlike util.Date(!) - to nanosecond precision:

[LocalTime, JDOC](https://docs.oracle.com/javase/10/docs/api/java/time/LocalTime.html):
> A time without a time-zone in the ISO-8601 calendar system, **such as 10:15:30**.
LocalTime is an immutable date-time object that represents a time, **often viewed as hour-minute-second**. Time is **represented to nanosecond precision**. For example, the value **"13:45.30.123456789"** can be stored in a LocalTime. ...

[LocalDateTime, JDOC](https://docs.oracle.com/javase/10/docs/api/java/time/LocalDateTime.html):
>A date-time without a time-zone in the ISO-8601 calendar system, **such as 2007-12-03T10:15:30**.  
> LocalDateTime is an immutable date-time object that represents a date-time, **often viewed as year-month-day-hour-minute-second**. Other date and time fields, such as day-of-year, day-of-week and week-of-year, can also be accessed. Time is represented to nanosecond precision. For example, the value **"2nd October 2007 at 13:45.30.123456789"** can be stored in a LocalDateTime. ...

# Converting LocalDate, LocalTime, LocalDateTime into util.Date using sql.Date

[Source: Stack Overflow](https://stackoverflow.com/a/28564046)
{% highlight java %}
Date date = java.sql.Date.valueOf(localDate);
Date date = java.sql.Time.valueOf(localTime);  
Date date = java.sql.Timestampe.valueOf(localDateTime);  
{% endhighlight %}
